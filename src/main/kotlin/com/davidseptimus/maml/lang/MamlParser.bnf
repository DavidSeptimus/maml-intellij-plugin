{
  parserClass="com.davidseptimus.maml.lang.parser.MamlParser"
  parserUtilClass="com.davidseptimus.maml.lang.parser.MamlParserUtil"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="Maml"
  psiImplClassSuffix="Impl"
  psiPackage="com.davidseptimus.maml.lang.psi"
  psiImplPackage="com.davidseptimus.maml.lang.psi.impl"
  elementTypeHolderClass="com.davidseptimus.maml.lang.psi.MamlTypes"
  elementTypeClass="com.davidseptimus.maml.lang.psi.MamlElementType"
  tokenTypeClass="com.davidseptimus.maml.lang.psi.MamlTokenType"
}

// File can be empty or contain a single value
// Whitespace and comments are automatically handled by Grammar-Kit
mamlFile ::= value?

value ::= object | array | STRING | MULTILINE_STRING | NUMBER | TRUE | FALSE | NULL | invalid_value {
  implements="com.davidseptimus.maml.lang.psi.MamlValueElement"
  mixin="com.davidseptimus.maml.lang.psi.MamlValueMixin"
}

// Invalid/partial value - used for error recovery (e.g., incomplete keywords like "fa" for "false")
invalid_value ::= IDENTIFIER | UNTERMINATED_STRING

// Object with error recovery - pin after opening brace
object ::= LBRACE members? RBRACE {
  pin=1
}

// Members can be separated by commas or newlines (which are in whitespace)
// The separator is optional - newlines in whitespace act as implicit separators
members ::= key_value_recoverable (COMMA? key_value_recoverable)* COMMA?

// Wrap key_value with recovery to continue parsing after errors
private key_value_recoverable ::= key_value | incomplete_key_value {
  recoverWhile=key_value_recover
}

// Complete key-value pair - pin after seeing the colon (not the key)
key_value ::= key COLON value {
  pin=2
  methods=[getPresentation]
}

// Incomplete key-value pair - just a key without colon (for completion/error recovery)
// Uses lookahead to only match if NOT followed by colon
incomplete_key_value ::= key &(!(COLON)) {
  methods=[getPresentation]
}

// Recovery: skip tokens until we see what could be the next key, end of object, comma, or EOF
private key_value_recover ::= !(RBRACE | STRING | IDENTIFIER | COMMA | <<eof>>)

key ::= STRING | IDENTIFIER {
  implements="com.davidseptimus.maml.lang.psi.MamlNamedElement"
  mixin="com.davidseptimus.maml.lang.psi.MamlKeyMixin"
}

// Array with error recovery - pin after opening bracket
array ::= LBRACKET items? RBRACKET {
  pin=1
}

// Items can be separated by commas or newlines (which are in whitespace)
// The separator is optional - newlines in whitespace act as implicit separators
items ::= value_recoverable (COMMA? value_recoverable)* COMMA?

// Wrap value with recovery to continue parsing after errors in arrays
private value_recoverable ::= value {
  recoverWhile=array_value_recover
}

// Recovery: skip until we see something that could start a value, end of array, comma, or EOF
private array_value_recover ::= !(RBRACKET | LBRACE | LBRACKET | STRING | MULTILINE_STRING | NUMBER | TRUE | FALSE | NULL | IDENTIFIER | COMMENT | COMMA | <<eof>>)